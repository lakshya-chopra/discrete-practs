from numpy import array

class Relation:
 
    def __init__(self, matrix):
        self.matrix = matrix
        self.length = len(matrix)

    def reflexive(self):
        for i in range(self.length):
            if not self.matrix[i][i]:
                return False
        return True
    
    def symmetric(self):
        for i in range(self.length):
            for j in range(self.length):
                if self.matrix[i][j] != self.matrix[j][i]:
                    return False
        return True
    
    def transitive(self):
        for i in range(self.length):
            for j in range(self.length):
                for k in range(self.length):
                    if self.matrix[i][j] and self.matrix[j][k] and not self.matrix[i][k]:
                            return False
        return True
    
    def anti_symmetric(self):
        for i in range(self.length):
            for j in range(self.length):
                if i != j and self.matrix[i][j] and self.matrix[j][i]:
                    return False
        return True

    def total_order(self):
        if self.anti_symmetric() and self.reflexive() & self.transitive():
            for i in range(self.length):
                for j in range(self.length):
                    if self.matrix[i][j] != 1:
                        return False
            return True

def gen_matrix():

    lst = list(map(int, input("Enter All the relations in a list form (separated by a space): ").split()))

    row,col = map(int,input("Rows, Columns : ").split())

    matrix = array(lst).reshape(row, col)

    print("The matrix thus formed is: \n", matrix)

    return matrix

def main():
    rel = Relation(gen_matrix())

    if rel.reflexive() and rel.symmetric() and rel.transitive():
        return "Equivalence Relation."

    elif rel.reflexive() and rel.anti_symmetric() and rel.transitive():
        if rel.total_order():
            return "Totally Ordered relation"
        else:
            return "Partially Ordered"
        
    else:
        return "None"

if __name__ == "__main__":
 print(main())


"""

from numpy import array:
To array function from the numpy library, which is used for creating numpy arrays and handling operations on matrices.

Now, in the relation class, we have:

Constructor (__init__): Initializes the relation with a matrix and calculates its length.
reflexive(): Checks if every element on the diagonal of the matrix is true (1), which is necessary for a relation to be reflexive.
symmetric(): Checks if the matrix is symmetric, i.e., for all i, j, matrix[i][j] should be equal to matrix[j][i].
transitive(): Verifies if for all i, j, k, whenever matrix[i][j] and matrix[j][k] are true, then matrix[i][k] should also be true.
anti_symmetric(): For all i and j where i â‰  j, if matrix[i][j] and matrix[j][i] are both true, the relation is not anti-symmetric.
total_order(): Checks if the relation is anti-symmetric, reflexive, and transitive, and additionally, every pair of elements are comparable (i.e., matrix[i][j] should be 1 for all i, j).
Helper Functions
gen_matrix(): This function reads user input for relation elements and the dimension of the matrix, creates a matrix from these inputs, and returns it.
Main Function
main(): Initializes the Relation with a matrix generated by gen_matrix(), then checks if the relation is an equivalence relation (reflexive, symmetric, transitive) or a (totally or partially) ordered relation (reflexive, anti-symmetric, transitive). It outputs a string indicating the type of relation.


The if __name__ == "__main__" block is used to run the main function when the script is executed as the main program.


"""